#!/usr/bin/env bash
# vibe-worktree — parallel Claude Code worktree setup for vibe coders
#
# Creates isolated git worktrees so you can run multiple Claude Code
# sessions in parallel — each on its own branch, no context bleed.
#
# Based on the pattern from: https://x.com/bcherny/status/2025007393290272904
# "Keep a 'main' worktree as your integration branch and only merge in
#  from the parallel ones." — r/ClaudeAI
#
# Usage:
#   ./tools/vibe-worktree.sh create <name> [base-branch]
#   ./tools/vibe-worktree.sh list
#   ./tools/vibe-worktree.sh remove <name>
#   ./tools/vibe-worktree.sh launch <name>
#   ./tools/vibe-worktree.sh clean-merged
#   ./tools/vibe-worktree.sh --help

set -euo pipefail

# ─── Config ──────────────────────────────────────────────────────────────────

WORKTREE_DIR="${VIBE_WORKTREE_DIR:-.worktrees}"
BASE_PORT="${VIBE_BASE_PORT:-3100}"  # port n+1 per worktree to avoid conflicts
CLAUDE_CMD="${CLAUDE_CMD:-claude}"   # override if claude is aliased differently

# ─── Helpers ─────────────────────────────────────────────────────────────────

usage() {
  cat <<USAGE
vibe-worktree — parallel Claude Code worktree manager

Commands:
  create <name> [base]   Create a worktree + branch (base defaults to HEAD)
  list                   List all active worktrees with ports
  remove <name>          Remove a worktree and delete its branch
  launch <name>          Launch Claude Code inside the worktree
  clean-merged           Remove worktrees whose branches are merged to main
  --help                 Show this message

Environment:
  VIBE_WORKTREE_DIR  Where worktrees are stored (default: .worktrees/)
  VIBE_BASE_PORT     Starting dev port, increments per slot (default: 3100)
  CLAUDE_CMD         Claude CLI command (default: claude)

Examples:
  # Spin up 3 parallel feature sessions
  ./tools/vibe-worktree.sh create feat-auth
  ./tools/vibe-worktree.sh create feat-ui
  ./tools/vibe-worktree.sh create feat-api

  # See them all with their ports
  ./tools/vibe-worktree.sh list

  # Open Claude Code in one
  ./tools/vibe-worktree.sh launch feat-auth

  # Clean up merged branches
  ./tools/vibe-worktree.sh clean-merged

USAGE
}

red()   { echo -e "\033[31m$*\033[0m"; }
green() { echo -e "\033[32m$*\033[0m"; }
bold()  { echo -e "\033[1m$*\033[0m"; }
info()  { echo "  → $*"; }

git_root() {
  git rev-parse --show-toplevel 2>/dev/null || {
    red "Error: not inside a git repository."
    exit 1
  }
}

# Compute a stable port slot from a worktree name (1-based offset from BASE_PORT)
port_for_name() {
  local name="$1"
  local root
  root="$(git_root)"
  local state_file="$root/$WORKTREE_DIR/.ports"
  mkdir -p "$root/$WORKTREE_DIR"
  touch "$state_file"

  # Return existing slot if already assigned
  if grep -q "^$name=" "$state_file" 2>/dev/null; then
    grep "^$name=" "$state_file" | cut -d= -f2
    return
  fi

  # Find next free port slot
  local used
  used=$(awk -F= '{print $2}' "$state_file" 2>/dev/null | sort -n)
  local port="$BASE_PORT"
  while echo "$used" | grep -q "^$port$"; do
    port=$((port + 1))
  done

  echo "$name=$port" >> "$state_file"
  echo "$port"
}

free_port_slot() {
  local name="$1"
  local root
  root="$(git_root)"
  local state_file="$root/$WORKTREE_DIR/.ports"
  if [[ -f "$state_file" ]]; then
    grep -v "^$name=" "$state_file" > "${state_file}.tmp" || true
    mv "${state_file}.tmp" "$state_file"
  fi
}

write_env_file() {
  local path="$1"
  local port="$2"
  local name="$3"
  cat > "$path/.env.local" <<EOF
# Auto-generated by vibe-worktree — safe to edit
PORT=$port
# Worktree: $name
# Created: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
EOF
}

write_claude_note() {
  local path="$1"
  local name="$2"
  local port="$3"
  local branch="$4"
  cat > "$path/WORKTREE.md" <<EOF
# Worktree: $name

This is an isolated git worktree for parallel Claude Code development.

- **Branch:** \`$branch\`
- **Dev port:** $port (set in \`.env.local\`)
- **Parent repo rules:** See root \`CLAUDE.md\` / \`.cursorrules\` (inherited)

## Workflow

1. Make changes here freely — this branch is isolated.
2. Run dev server on port $port to avoid conflicts with other worktrees.
3. When done, open a PR from \`$branch\` → \`main\`.
4. Merge via main repo — do NOT push directly to main.

## Cleanup

From the main repo root:
\`\`\`bash
./tools/vibe-worktree.sh remove $name
\`\`\`
EOF
}

# ─── Commands ────────────────────────────────────────────────────────────────

cmd_create() {
  local name="${1:-}"
  local base="${2:-HEAD}"

  if [[ -z "$name" ]]; then
    red "Error: name required. Usage: vibe-worktree create <name> [base-branch]"
    exit 1
  fi

  local root
  root="$(git_root)"
  local wt_path="$root/$WORKTREE_DIR/$name"

  if [[ -d "$wt_path" ]]; then
    red "Error: worktree '$name' already exists at $wt_path"
    exit 1
  fi

  local branch="wt/$name"
  local port
  port="$(port_for_name "$name")"

  bold "Creating worktree: $name"
  info "Branch: $branch"
  info "Path:   $wt_path"
  info "Port:   $port"

  git worktree add -b "$branch" "$wt_path" "$base"

  write_env_file "$wt_path" "$port" "$name"
  write_claude_note "$wt_path" "$name" "$port" "$branch"

  # Add WORKTREE.md and .env.local to .gitignore inside worktree
  echo ".env.local" >> "$wt_path/.gitignore" 2>/dev/null || true
  echo "WORKTREE.md" >> "$wt_path/.gitignore" 2>/dev/null || true

  green "✓ Worktree ready: $wt_path"
  echo ""
  echo "  Launch Claude Code in it:"
  bold "    ./tools/vibe-worktree.sh launch $name"
  echo ""
  echo "  Or open manually:"
  bold "    cd $wt_path && claude"
}

cmd_list() {
  local root
  root="$(git_root)"
  local state_file="$root/$WORKTREE_DIR/.ports"

  bold "Active worktrees:"
  echo ""

  local wt_output
  wt_output=$(git worktree list --porcelain)

  print_wt_entry() {
    local p="$1" b="$2" prune="$3"
    [[ -z "$p" ]] && return
    local n
    n="$(basename "$p")"
    local port="—"
    if [[ -f "$state_file" ]] && grep -q "^$n=" "$state_file" 2>/dev/null; then
      port=$(grep "^$n=" "$state_file" | cut -d= -f2)
    fi
    local flag=""
    [[ "$prune" == "1" ]] && flag=" (prunable)"
    printf "  %-24s  branch: %-30s  port: %s%s\n" "$n" "${b:-HEAD}" "$port" "$flag"
  }

  local path="" branch="" prunable=0
  while IFS= read -r line; do
    if [[ "$line" == worktree\ * ]]; then
      # flush previous entry
      print_wt_entry "$path" "$branch" "$prunable"
      path="${line#worktree }"; branch=""; prunable=0
    elif [[ "$line" == branch\ * ]]; then
      branch="${line#branch refs/heads/}"
    elif [[ "$line" == prunable* ]]; then
      prunable=1
    fi
  done <<< "$wt_output"
  # flush last entry
  print_wt_entry "$path" "$branch" "$prunable"
  echo ""
}

cmd_remove() {
  local name="${1:-}"
  if [[ -z "$name" ]]; then
    red "Error: name required. Usage: vibe-worktree remove <name>"
    exit 1
  fi

  local root
  root="$(git_root)"
  local wt_path="$root/$WORKTREE_DIR/$name"
  local branch="wt/$name"

  if [[ ! -d "$wt_path" ]]; then
    red "Error: worktree '$name' not found at $wt_path"
    exit 1
  fi

  bold "Removing worktree: $name"
  git worktree remove --force "$wt_path" 2>/dev/null || true
  git branch -D "$branch" 2>/dev/null && info "Deleted branch $branch" || info "Branch $branch not found (already deleted?)"
  free_port_slot "$name"

  green "✓ Removed: $name"
}

cmd_launch() {
  local name="${1:-}"
  if [[ -z "$name" ]]; then
    red "Error: name required. Usage: vibe-worktree launch <name>"
    exit 1
  fi

  local root
  root="$(git_root)"
  local wt_path="$root/$WORKTREE_DIR/$name"

  if [[ ! -d "$wt_path" ]]; then
    red "Error: worktree '$name' not found. Run: vibe-worktree create $name"
    exit 1
  fi

  # Check if Claude Code 2.1.49+ --worktree flag is available
  if "$CLAUDE_CMD" --help 2>&1 | grep -q -- "--worktree"; then
    bold "Launching Claude Code with --worktree flag (2.1.49+)..."
    cd "$wt_path" && exec "$CLAUDE_CMD" --worktree
  else
    bold "Launching Claude Code in worktree directory..."
    cd "$wt_path" && exec "$CLAUDE_CMD"
  fi
}

cmd_clean_merged() {
  local main_branch
  main_branch=$(git remote show origin 2>/dev/null | grep 'HEAD branch' | awk '{print $NF}' || echo "main")

  bold "Cleaning merged worktree branches (merged to $main_branch)..."
  echo ""

  local count=0
  while IFS= read -r branch; do
    local name="${branch#wt/}"
    info "Removing merged: $branch ($name)"
    cmd_remove "$name"
    count=$((count + 1))
  done < <(git branch --merged "$main_branch" | grep 'wt/' | tr -d ' ')

  if [[ "$count" -eq 0 ]]; then
    info "Nothing to clean — no merged wt/* branches found."
  else
    green "✓ Cleaned $count worktree(s)"
  fi
}

# ─── Main ────────────────────────────────────────────────────────────────────

main() {
  case "${1:-}" in
    create)       shift; cmd_create "$@" ;;
    list)         cmd_list ;;
    remove|rm)    shift; cmd_remove "$@" ;;
    launch)       shift; cmd_launch "$@" ;;
    clean-merged) cmd_clean_merged ;;
    --help|-h)    usage ;;
    "")           usage ;;
    *)
      red "Unknown command: $1"
      echo ""
      usage
      exit 1
      ;;
  esac
}

main "$@"
